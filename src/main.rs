use clap::{Parser, ValueEnum, command, arg, ArgGroup, value_parser};

// Attaching modules to module tree
mod netcode;
mod card;
mod game;

use crate::netcode::client_server;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // let args = Args::parse();
    let matches = command!()
        .group(ArgGroup::new("mode").required(true).multiple(false))
        .arg(
            arg!(-c --client)
            .help("Run as client")
            .group("mode")
            )
        .arg(
            arg!(-n --name <VALUE>)
            .help("Enter a name. If not used, a randomly generated name will be used instead!")
            .conflicts_with("server")
            )
        .arg(
            arg!(-s --server)
            .help("Run as server")
            .group("mode")
            )
        .arg(
            arg!(-o --open)
            .help("Start an Open (public) server which anyone can join.
                  If this flag isn't used, the clients will need to use a join code generated by this server")
            .conflicts_with("client")
            )
        .arg(
            arg!(-p --port <VALUE>)
            .help("Specify port number")
            .value_parser(value_parser!(u32).range(1..))
            .default_value("8080"),
            )
        // .arg(
        //     arg!(-v --verbose)
        //     .help("Enable verbose mode")
        //     )
        // .arg(
        //     arg!("name")
        //     .short('n')
        //     .long("name")
        //     // .about("Specify name (client mode only)")
        //     .requires_if("mode", "client"),
        //     )
        .get_matches();

    let port = *matches.get_one("port").unwrap();
    let is_open = *matches.get_one("open").unwrap();
    if *matches.get_one("server").unwrap() {
        client_server::run_server(port, is_open).await?;
    }

    if *matches.get_one("client").unwrap() {
        client_server::run_client(port, matches.get_one("name"),).await?;
    }
    Ok(())
}



